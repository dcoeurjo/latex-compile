#!/usr/bin/env python2

import subprocess
import os, re, sys, time, string
import argparse

re_file_line_error= re.compile(r'.*:[0-9]*:.*')

re_warning = re.compile(
"(LaTeX|Package)( (?P<pkg>.*))? Warning: (?P<text>.*)$")

re_package_error = re.compile(".*Package (?P<pkg>.*) Error: .*$")

class LatexCompileError(Exception): pass
class BibtexError(Exception): pass

def run_pdflatex():
    """Run pdflatex on jobname.
    In case of success, return silently.
    In case of error, pretty-print the error message and raise a LatexCompileError."""
        
    try:
        log=subprocess.check_output(["pdflatex",
                                      "-halt-on-error",
                                      "-file-line-error",
                                      "-synctex=1",
                                      "-shell-escape",
                                      "-interaction=nonstopmode",
                                      jobname],
                                     stderr=subprocess.STDOUT,
                                 )
        return 
    except subprocess.CalledProcessError as e:
        pass # let the control flow back outside the try/except block

    log=e.output.splitlines()
    
    acc=""
    prefix=None
    for line in log:
        
        # TeX breaks outputs at 79 characters. here we rejoin the fragments
        if len(line)==79:
            acc+=line
            continue
        elif acc:
            line=acc+line
            acc=""

        # long error logic. cf #14 #37
        if prefix is not None:
            if line[:len(prefix)] == prefix:
                text.append( line[len(prefix):].strip() )
            else:
                line=" ".join(text)
                break

        if "LaTeX Error:" in line: # cf #07
            break

        if re_package_error.match(line):
            m=re_package_error.match(line)
            prefix = "(%s)" % m.groupdict()["pkg"]
            text = [line]
            continue
            
        if re_file_line_error.search(line):
            break

    else:
        print "could not understand error ; dumping raw logfile"
        # try to be useful even if we could not understand the log
        print "..."
        print "..."
        print "\n".join( log[-10:] ) # cf #33

        raise LatexCompileError # notify caller of compile error

    # 1) display the (pretty-printed) main error message
    print line

    # 2) print the details, i.e. everything up to the offending line
    try:
        # first, we try locate the main error message, so as to start from there
        i=1+log.index(line[:79]) # :79 to unjoin line cf #37
    except ValueError:
        # Note: this happens for instance in test-cases #16, which I
        # don't want to write specific logic for. take that, fancyvrb.
        raise LatexCompileError #notify caller of compile error
    
    for detail in log[i:]:
        if detail.strip() in line:
            # discard this fragment if already joined into "line"
            continue
        if prefix is not None: # iff we are dealing with a package error
            # similarly: discard long-error fragments when already joined
            if detail[ len(prefix):].strip() in line:
                continue
            # and discard generic RTFM advice
            if detail == "See the "+prefix[1:-1]+" package documentation for explanation.":
                continue
        # supress superfluous noise: RTFM, boilerplate, etc.
        if detail.strip() in ["See the LaTeX manual or LaTeX Companion for explanation.",
                              "Type  H <return>  for immediate help.",
                              "Type X to quit or <RETURN> to proceed,",
                              "Enter file name:",
                              "...", "<read *>",
                              ""]:
            continue
        # suppress interactive querying for all extensions (.sty and others)
        if "or enter new name. (Default extension:" in detail:
            continue

        print detail

        # Have we reached the offending line yet ?
        if detail[:2] == "l.": 
            j=log.index(detail) # kludge
            if log[j+1].strip(): # offending line is sometimes displayed broken in two pieces cf #14
                print log[j+1]
            break    
    
    raise LatexCompileError # notify caller of compile error

def bibtex_needed(old_aux,new_aux):
    log=open( jobname+".log" ).read()
    
    if "No file "+jobname+".bbl" in log:
        # print "bibtex is needed because no file "+jobname+".bbl"
        return True # test-cases #03, #15...
             
    if ( os.path.isfile(jobname+".bbl") and # test-case #15
        ("LaTeX Warning: Citation " in log)): # test-case #22
        # print "bibtex is needed because Citation undefined"
        return True

    # design note: we rerun bibtex even if there were only warnings,
    # so as to annoy the user, hoping for them to correct their .bib
    # files :-)
    if os.path.isfile(jobname+".blg"):
        blg=open( jobname+".blg" ).read()
        if "error message" in blg: return True # test-case #31
        if "Warning--" in blg: return True # test-case #32

    # detect hard-coded bibliographies (and maybe other corner cases)
    # which don't use bibtex at all. (cf e.g. #15)
    if not os.path.isfile(jobname+".bbl") and not os.path.isfile(jobname+".blg"):
        return False

    # on a fresh document, the aux file doesn't exist before the first pass
    if old_aux is None:
        old_aux=""
        
    old_citations = [ line[10:-1] for line in old_aux.splitlines() if line[:10] == r'\citation{' ]
    new_citations = [ line[10:-1] for line in new_aux.splitlines() if line[:10] == r'\citation{' ]

    # compare both sets to detect new or removed citations (cf #22 #40)
    if set(old_citations) != set(new_citations):
        # print "bibtex is needed because some citations have added or removed"
        return True

    if os.path.isfile(jobname+".blg"): # cf test-case #49
        last_bibtex_time = os.path.getmtime(jobname+".blg")
        bibnames=[ line[18:].strip() for line in open( jobname+".blg" ).readlines() if 'Database file' in line ]
        for bibname in bibnames: # iterate over all bibtex files, cf test-case #50
            if '-blx.bib' in bibname: continue # irrelevant because this one is biblatex-generated
            if os.path.getmtime(bibname) >= last_bibtex_time:
                return True

    return False

def run_bibtex():
        print "running BibTeX on %s..." % jobname
    
        # design  note: I  decide to  abort  the build  process on  bibtex
        # errors, but to proceed on warnings
        #
        # and anyway, we remain silent if no errors nor warnings
    
        bibtex_output=None
        try:
            bibtex_output=subprocess.check_output(["bibtex",jobname])
        except subprocess.CalledProcessError as e:
            print "" # an empty line
            print e.output,
            # Nirvana: pretty-print bibtex errors ?
            raise BibtexError
        
        if "Warning--" in bibtex_output:
            # just repeat what bibtex said.
            print bibtex_output,
            # Nirvana: pretty-print bibtex warnings ?


#####################################################################
# Page and file tracking logic.
#
# keeps track of current document page and current source file so that
# warnings and errors are reported with relevant details

def tracker_init():
    """reset the page/file tracker state"""
    # page tracking
    global tracker_current_pagenum
    tracker_current_pagenum = 1
    global tracker_max_pagenum
    tracker_max_pagenum = tracker_guess_max_pagenum()
    # file tracking
    global tracker_update_currentfile_should_skip_line
    tracker_update_currentfile_should_skip_line=False
    global tracker_opened_files
    tracker_opened_files=[]
    global tracker_print_all_filenames
    tracker_print_all_filenames=False # Once we started printing filenames, we will print them all

# Page tracking logic

# GS-29/04/2014-16:07. remove the closing bracket. see test-cases.
# GS-22/05/2014-12:11. add the non-capturing-group matching end-of-string
re_page = re.compile("\[(?P<num>[0-9]+)(?:$|[^/0-9])")

def tracker_guess_max_pagenum():
    log=open( jobname+".log" ).read()
    for line in log.splitlines():
        if "Output written on "+jobname+".pdf" in line:
            return int(line.split('(')[1].split()[0])
            
def tracker_update_page (line):
    """Parse the given log line and return the number of the page that is
    being built after that line,  assuming the current page before the
    line was `before'.
    """
    global tracker_current_pagenum
    ms = re_page.findall(line)
    if ms:
        tracker_current_pagenum = max(tracker_current_pagenum, int(ms[-1]) + 1)

# File tracking logic
def tracker_update_currentfile (line):
    """Parse the given logline and keep track of the file being processed"""
    
    # if line.count('(' ) + line.count(')'):
    #     print '##%d#%d##' % (line.count('('),
    #                          line.count(')') ) , line
    #     print "opened files:", tracker_opened_files

    # using a global variable is a kludge, but it works. suggestions welcome.
    global tracker_update_currentfile_should_skip_line
    if tracker_update_currentfile_should_skip_line:
        tracker_update_currentfile_should_skip_line=False
        return 
    # skip the (dangerous) line after a badbox warning, so as not to
    # be confused by text coming from the document (test-cases #35, #42)
    if line.startswith("Underfull") or line.startswith("Overfull"):
        tracker_update_currentfile_should_skip_line=True
        pass

    # we  walk the  logline one  character  at a  time, searching  for
    # parentheses,  and tracking  nesting level.  Some of  the opening
    # parentheses are  followed by a pathname,  so we push these  on a
    # pathname stack.
    while line:
        if line[0] is ')':
            try:
                tracker_opened_files.pop()
                # print "->",tracker_opened_files        
            except:
                # the try/except fixes test-case #51
                pass

        if line[0] is '(':
            suffix=line[1:]

            # if suffix does not even look like a pathname, let's not bother walking it
            if suffix[0] not in './':
                suffix=""
        
            # what we want is the longest prefix of suffix that _is_ a pathname
            while suffix and not os.path.isfile(suffix):
                suffix=suffix[:-1]

            tracker_opened_files.append(suffix)
            # print "->",tracker_opened_files

        line = line[1:]

def tracker_get_current_file():
    """Returns the filename where the tracker believes we are"""
    for i in range(-1, -len(tracker_opened_files)-1,-1):
        if tracker_opened_files[i]:
            return tracker_opened_files[i]
    # GS-2018-04-10-17:06 bugfix for test-case #48
    return "./"+jobname+".tex"

def tracker_print_warning(text):
    """Prints either `text', `file:line text', or text (page n), etc."""
    global tracker_print_all_filenames
    if tracker_print_all_filenames or (tracker_get_current_file() != "./"+jobname+".tex"):
        print "in file %s:"%tracker_get_current_file(),
        tracker_print_all_filenames = True
    if tracker_current_pagenum > tracker_max_pagenum:
        # page number is obviously wrong => unhelpful => skip it
        print text
    else:
        print text + " (page %d)" % tracker_current_pagenum

#####################################################################
# Warning pretty-print
    
def print_warnings():
    log=open( jobname+".log" ).read()
    tracker_init()
    
    prefix=None
    acc=""
    for line in log.splitlines():

        # TeX breaks outputs at 79 characters. here we rejoin the fragments
        if len(line)==79:
            acc+=line
            continue
        elif acc:
            line=acc+line
            acc=""

        # Long warning logic, stolen from rubber
        if prefix is not None: # then we may or may not have some more lines to accumulate
            if line[:len(prefix)] == prefix: # then this line belongs to the current in-construction warning
                text.append(string.strip(line[len(prefix):])) # accumulate
            else: # we are past the end of the warning, it's now time to spit it out
                tracker_print_warning( " ".join(text))
                prefix = None

        tracker_update_page(line)
        tracker_update_currentfile(line) 
        
        if (options.nobadboxes == False and
            ( "Overfull " in line or
              "Underfull " in line )):
            tracker_print_warning(line)

        if "Warning: " in line:
            m = re_warning.match(line)
            if m:
                pkg= m.groupdict()["pkg"] # either offended package name, or None
                if pkg:
                    text = [line]
                    # next line(s), if any, will have the package name followed by a lot of spaces, cf #26
                    prefix = ("(%s)" % pkg).ljust(m.start("text"))
                    
                else: # this is a proper "LaTeX Warning"
                    if "Unused global option" in line: # cf #46
                        text = [line]
                        prefix="    "
                    else:
                        tracker_print_warning(line)
                
        if "pdfTeX warning:" in line: # see test-case #36
            tracker_print_warning(line)

#####################################################################
# Main compilation stuff
            
def snapshot():
    """Take a 'snapshot' of known auxiliary files.
Returns a dictionary where keys are file names and values are file contents."""

    suffixes =  [".aux",".glo",".bbl",".blg"]
    snapshot=dict()
    for filename in [ jobname + suffix for suffix in suffixes]:
        if os.path.exists(filename):
           snapshot[filename]=open(filename,"r").read()
        else:
            snapshot[filename]=None
    return snapshot

def changedfiles(oldsnapshot, newsnapshot):
    """Compare the two snapshots and return an iterator with all the filenames that differ"""
    for filename in newsnapshot:
        if filename not in oldsnapshot:
            yield filename
        elif oldsnapshot[filename] <> newsnapshot[filename]:
            yield filename

# note: each of the functions we call here will raise an exception if
# something goes wrong -> no need for explicit error-checking
def latex_full_build():
    before=snapshot()
    print "compiling %s..." % (jobname+'.tex')
    run_pdflatex() # if errors, will print them before raising exception
    after=snapshot()

    if bibtex_needed(before[jobname+".aux"],after[jobname+".aux"]):
        run_bibtex()
        after=snapshot() # bibtex may or may not require a recompilation (cf #45 #32)

    # We recompile the latex document stubbornly until all the
    # auxiliary files (ie .aux .log etc) reach a fixpoint.
    while before <> after:
        for filename in changedfiles(before, after):
            # print "file changed:", filename
            if filename == jobname+".glo": # cf #38 and #39
                print "running makeglossaries on %s..." % jobname
                subprocess.check_output(["makeglossaries",jobname])
            
        before=snapshot()
        print "recompiling %s..." % (jobname+'.tex')
        run_pdflatex() 
        after=snapshot()
    
    print_warnings()

#####################################################################
# Conmmand-line Interface

jobname=None
if __name__ == '__main__':

    # option parsing
    argparser = argparse.ArgumentParser()
    argparser.add_argument('--version', help='print version information and exit',action="version",
                           version='%(prog)s 2018-10-01')
    argparser.add_argument('-l','--loop', help='loop-forever mode',action="store_true")
    argparser.add_argument('-b','--nobadboxes', help='ignore warnings about overfull and underfull boxes', action="store_true")
    argparser.add_argument('filename',metavar='FILENAME', help='your latex file')
    options=argparser.parse_args()

    # argument parsing
    jobname=options.filename
    if not os.path.exists(jobname+'.tex'): jobname=jobname.replace('.tex','')
    if not os.path.exists(jobname+'.tex'): 
        print argparser.prog+": cannot find file '"+options.filename+"'"
        sys.exit(1)

    # run-once-only mode
    if not options.loop:
        try:
            latex_full_build()
        except (LatexCompileError,BibtexError):
            sys.exit(1)
        else:
            sys.exit(0)

    # run-forever mode
    try:
        latex_full_build()
    except (LatexCompileError,BibtexError):
        pass
    except KeyboardInterrupt:
        print# newline after ^C to look good
        sys.exit(0)
    
    while True:

        try:
            time.sleep(1)
        except KeyboardInterrupt:
            print# newline after ^C to look good
            sys.exit(0)

        last_compile_time=os.path.getmtime(jobname+".log")

        must_recompile=False
        for (dirpath,subdirs,filenames) in os.walk("."):
            for filename in filenames:
                filepath=dirpath+"/"+filename
                if not os.path.isfile(filepath): continue 
                if os.path.getmtime(filepath) > last_compile_time:
                    # print "recent file:", filepath
                    must_recompile=True
                    
        if not must_recompile:
            continue

        try:
            latex_full_build()
        except (LatexCompileError,BibtexError):
            # print 70*'='
            time.sleep(1)
        except KeyboardInterrupt:
            print# newline after ^C to look good
            sys.exit(0)
